//#region src/web/compression.ts
function createGzipEncoder() {
	return new CompressionStream("gzip");
}
function createGzipDecoder() {
	return new DecompressionStream("gzip");
}

//#endregion
//#region src/web/options.ts
function createTarOptionsTransformer(options = {}) {
	return new TransformStream({ async transform(entry, controller) {
		let header = entry.header;
		const stripCount = options.strip;
		if (stripCount && stripCount > 0) {
			const newName = stripPathComponents(header.name, stripCount);
			if (newName === null) {
				drainStream(entry.body);
				return;
			}
			let newLinkname = header.linkname;
			if (newLinkname?.startsWith("/")) {
				const strippedLinkTarget = stripPathComponents(newLinkname, stripCount);
				newLinkname = strippedLinkTarget === null ? "/" : `/${strippedLinkTarget}`;
			}
			header = {
				...header,
				name: header.type === "directory" && !newName.endsWith("/") ? `${newName}/` : newName,
				linkname: newLinkname
			};
		}
		if (options.filter && options.filter(header) === false) {
			drainStream(entry.body);
			return;
		}
		if (options.map) header = options.map(header);
		controller.enqueue({
			header,
			body: entry.body
		});
	} });
}
function stripPathComponents(path, stripCount) {
	const components = path.split("/").filter((c) => c.length > 0);
	if (stripCount >= components.length) return null;
	return components.slice(stripCount).join("/");
}
function drainStream(stream) {
	(async () => {
		const reader = stream.getReader();
		try {
			while (true) {
				const { done } = await reader.read();
				if (done) break;
			}
		} catch (error) {
			console.debug("Stream drain error (non-critical):", error);
		} finally {
			reader.releaseLock();
		}
	})();
}

//#endregion
//#region src/web/constants.ts
const BLOCK_SIZE = 512;
const BLOCK_SIZE_MASK = 511;
const DEFAULT_FILE_MODE = 420;
const DEFAULT_DIR_MODE = 493;
const USTAR_NAME_OFFSET = 0;
const USTAR_NAME_SIZE = 100;
const USTAR_MODE_OFFSET = 100;
const USTAR_MODE_SIZE = 8;
const USTAR_UID_OFFSET = 108;
const USTAR_UID_SIZE = 8;
const USTAR_GID_OFFSET = 116;
const USTAR_GID_SIZE = 8;
const USTAR_SIZE_OFFSET = 124;
const USTAR_SIZE_SIZE = 12;
const USTAR_MTIME_OFFSET = 136;
const USTAR_MTIME_SIZE = 12;
const USTAR_CHECKSUM_OFFSET = 148;
const USTAR_CHECKSUM_SIZE = 8;
const USTAR_TYPEFLAG_OFFSET = 156;
const USTAR_TYPEFLAG_SIZE = 1;
const USTAR_LINKNAME_OFFSET = 157;
const USTAR_LINKNAME_SIZE = 100;
const USTAR_MAGIC_OFFSET = 257;
const USTAR_MAGIC_SIZE = 6;
const USTAR_VERSION_OFFSET = 263;
const USTAR_VERSION_SIZE = 2;
const USTAR_UNAME_OFFSET = 265;
const USTAR_UNAME_SIZE = 32;
const USTAR_GNAME_OFFSET = 297;
const USTAR_GNAME_SIZE = 32;
const USTAR_PREFIX_OFFSET = 345;
const USTAR_PREFIX_SIZE = 155;
const USTAR_VERSION = "00";
const USTAR_MAX_UID_GID = 2097151;
const USTAR_MAX_SIZE = 8589934591;
const TYPEFLAG = {
	file: "0",
	link: "1",
	symlink: "2",
	"character-device": "3",
	"block-device": "4",
	directory: "5",
	fifo: "6",
	"pax-header": "x",
	"pax-global-header": "g",
	"gnu-long-name": "L",
	"gnu-long-link-name": "K"
};
const FLAGTYPE = {
	"0": "file",
	"1": "link",
	"2": "symlink",
	"3": "character-device",
	"4": "block-device",
	"5": "directory",
	"6": "fifo",
	x: "pax-header",
	g: "pax-global-header",
	L: "gnu-long-name",
	K: "gnu-long-link-name"
};

//#endregion
//#region src/web/utils.ts
const encoder = new TextEncoder();
const decoder = new TextDecoder();
function writeString(view, offset, size, value) {
	if (value) encoder.encodeInto(value, view.subarray(offset, offset + size));
}
function writeOctal(view, offset, size, value) {
	if (value === void 0) return;
	const octalString = value.toString(8).padStart(size - 1, "0");
	encoder.encodeInto(octalString, view.subarray(offset, offset + size - 1));
}
function readString(view, offset, size) {
	const end = view.indexOf(0, offset);
	const sliceEnd = end === -1 || end > offset + size ? offset + size : end;
	return decoder.decode(view.subarray(offset, sliceEnd));
}
function readOctal(view, offset, size) {
	let value = 0;
	const end = offset + size;
	for (let i = offset; i < end; i++) {
		const charCode = view[i];
		if (charCode === 0) break;
		if (charCode === 32) continue;
		value = (value << 3) + (charCode - 48);
	}
	return value;
}
function readNumeric(view, offset, size) {
	if (view[offset] & 128) {
		let result = 0;
		for (let i = 0; i < size; i++) result = result << 8 | view[offset + i];
		return result & ~(128 << (size - 1) * 8);
	}
	return readOctal(view, offset, size);
}
async function streamToBuffer(stream) {
	const chunks = [];
	const reader = stream.getReader();
	let totalLength = 0;
	try {
		while (true) {
			const { done, value } = await reader.read();
			if (done) break;
			chunks.push(value);
			totalLength += value.length;
		}
		const result = new Uint8Array(totalLength);
		let offset = 0;
		for (const chunk of chunks) {
			result.set(chunk, offset);
			offset += chunk.length;
		}
		return result;
	} finally {
		reader.releaseLock();
	}
}

//#endregion
//#region src/web/checksum.ts
const CHECKSUM_SPACE = 32;
const ASCII_ZERO = 48;
function validateChecksum(block) {
	const stored = readOctal(block, USTAR_CHECKSUM_OFFSET, USTAR_CHECKSUM_SIZE);
	let sum = 0;
	for (let i = 0; i < block.length; i++) if (i >= USTAR_CHECKSUM_OFFSET && i < USTAR_CHECKSUM_OFFSET + USTAR_CHECKSUM_SIZE) sum += CHECKSUM_SPACE;
	else sum += block[i];
	return stored === sum;
}
function writeChecksum(block) {
	block.fill(CHECKSUM_SPACE, USTAR_CHECKSUM_OFFSET, USTAR_CHECKSUM_OFFSET + USTAR_CHECKSUM_SIZE);
	let checksum = 0;
	for (const byte of block) checksum += byte;
	for (let i = USTAR_CHECKSUM_OFFSET + 6 - 1; i >= USTAR_CHECKSUM_OFFSET; i--) {
		block[i] = (checksum & 7) + ASCII_ZERO;
		checksum >>= 3;
	}
	block[USTAR_CHECKSUM_OFFSET + 6] = 0;
	block[USTAR_CHECKSUM_OFFSET + 7] = CHECKSUM_SPACE;
}

//#endregion
//#region src/web/pack-pax.ts
function generatePax(header) {
	const paxRecords = {};
	if (header.name.length > USTAR_NAME_SIZE) {
		if (findUstarSplit(header.name) === null) paxRecords.path = header.name;
	}
	if (header.linkname && header.linkname.length > USTAR_NAME_SIZE) paxRecords.linkpath = header.linkname;
	if (header.uname && header.uname.length > USTAR_UNAME_SIZE) paxRecords.uname = header.uname;
	if (header.gname && header.gname.length > USTAR_GNAME_SIZE) paxRecords.gname = header.gname;
	if (header.uid != null && header.uid > USTAR_MAX_UID_GID) paxRecords.uid = String(header.uid);
	if (header.gid != null && header.gid > USTAR_MAX_UID_GID) paxRecords.gid = String(header.gid);
	if (header.size != null && header.size > USTAR_MAX_SIZE) paxRecords.size = String(header.size);
	if (header.pax) Object.assign(paxRecords, header.pax);
	const paxEntries = Object.entries(paxRecords);
	if (paxEntries.length === 0) return null;
	const paxBody = encoder.encode(paxEntries.map(([key, value]) => {
		const record = `${key}=${value}\n`;
		const partLength = encoder.encode(record).length + 1;
		let totalLength = partLength + String(partLength).length;
		totalLength = partLength + String(totalLength).length;
		return `${totalLength} ${record}`;
	}).join(""));
	return {
		paxHeader: createTarHeader({
			name: decoder.decode(encoder.encode(`PaxHeader/${header.name}`).slice(0, 100)),
			size: paxBody.length,
			type: "pax-header",
			mode: 420,
			mtime: header.mtime,
			uname: header.uname,
			gname: header.gname,
			uid: header.uid,
			gid: header.gid
		}),
		paxBody
	};
}
function findUstarSplit(path) {
	if (path.length <= USTAR_NAME_SIZE) return null;
	const minSlashIndex = path.length - USTAR_NAME_SIZE - 1;
	const slashIndex = path.lastIndexOf("/", USTAR_PREFIX_SIZE);
	if (slashIndex > 0 && slashIndex >= minSlashIndex) return {
		prefix: path.slice(0, slashIndex),
		name: path.slice(slashIndex + 1)
	};
	return null;
}

//#endregion
//#region src/web/pack.ts
function createTarPacker() {
	let streamController;
	return {
		readable: new ReadableStream({ start(controller) {
			streamController = controller;
		} }),
		controller: {
			add(header) {
				const size = header.type === "directory" || header.type === "symlink" || header.type === "link" ? 0 : header.size ?? 0;
				const paxData = generatePax(header);
				if (paxData) {
					streamController.enqueue(paxData.paxHeader);
					streamController.enqueue(paxData.paxBody);
					const paxPadding = -paxData.paxBody.length & BLOCK_SIZE_MASK;
					if (paxPadding > 0) streamController.enqueue(new Uint8Array(paxPadding));
				}
				const headerBlock = createTarHeader({
					...header,
					size
				});
				streamController.enqueue(headerBlock);
				let totalWritten = 0;
				return new WritableStream({
					write(chunk) {
						totalWritten += chunk.length;
						if (totalWritten > size) {
							const err = /* @__PURE__ */ new Error(`Entry '${header.name}' is larger than its specified size of ${size} bytes.`);
							streamController.error(err);
							throw err;
						}
						streamController.enqueue(chunk);
					},
					close() {
						if (totalWritten !== size) {
							const err = /* @__PURE__ */ new Error(`Size mismatch for entry '${header.name}': expected ${size} bytes but received ${totalWritten}.`);
							streamController.error(err);
							throw err;
						}
						const paddingSize = -size & BLOCK_SIZE_MASK;
						if (paddingSize > 0) streamController.enqueue(new Uint8Array(paddingSize));
					},
					abort(reason) {
						streamController.error(reason);
					}
				});
			},
			finalize() {
				streamController.enqueue(new Uint8Array(BLOCK_SIZE * 2));
				streamController.close();
			},
			error(err) {
				streamController.error(err);
			}
		}
	};
}
function createTarHeader(header) {
	const view = new Uint8Array(BLOCK_SIZE);
	const size = header.type === "directory" || header.type === "symlink" || header.type === "link" ? 0 : header.size ?? 0;
	let name = header.name;
	let prefix = "";
	if (!header.pax?.path) {
		const split = findUstarSplit(name);
		if (split) {
			name = split.name;
			prefix = split.prefix;
		}
	}
	writeString(view, USTAR_NAME_OFFSET, USTAR_NAME_SIZE, name);
	writeOctal(view, USTAR_MODE_OFFSET, USTAR_MODE_SIZE, header.mode ?? (header.type === "directory" ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE));
	writeOctal(view, USTAR_UID_OFFSET, USTAR_UID_SIZE, header.uid ?? 0);
	writeOctal(view, USTAR_GID_OFFSET, USTAR_GID_SIZE, header.gid ?? 0);
	writeOctal(view, USTAR_SIZE_OFFSET, USTAR_SIZE_SIZE, size);
	writeOctal(view, USTAR_MTIME_OFFSET, USTAR_MTIME_SIZE, Math.floor((header.mtime?.getTime() ?? Date.now()) / 1e3));
	writeString(view, USTAR_TYPEFLAG_OFFSET, USTAR_TYPEFLAG_SIZE, TYPEFLAG[header.type ?? "file"]);
	writeString(view, USTAR_LINKNAME_OFFSET, USTAR_LINKNAME_SIZE, header.linkname);
	writeString(view, USTAR_MAGIC_OFFSET, USTAR_MAGIC_SIZE, "ustar\0");
	writeString(view, USTAR_VERSION_OFFSET, USTAR_VERSION_SIZE, USTAR_VERSION);
	writeString(view, USTAR_UNAME_OFFSET, USTAR_UNAME_SIZE, header.uname);
	writeString(view, USTAR_GNAME_OFFSET, USTAR_GNAME_SIZE, header.gname);
	writeString(view, USTAR_PREFIX_OFFSET, USTAR_PREFIX_SIZE, prefix);
	writeChecksum(view);
	return view;
}

//#endregion
//#region src/web/unpack.ts
function createTarDecoder(options = {}) {
	const strict = options.strict ?? false;
	const chunks = [];
	let totalLength = 0;
	let offset = 0;
	let currentEntry = null;
	let paxGlobals = {};
	let nextEntryOverrides = {};
function consume(size) {
		if (totalLength < size || chunks.length === 0) return null;
		totalLength -= size;
		const firstChunk = chunks[0];
		if (firstChunk.length - offset >= size) {
			const data$1 = firstChunk.slice(offset, offset + size);
			offset += size;
			if (offset === firstChunk.length) {
				chunks.shift();
				offset = 0;
			}
			return data$1;
		}
		const data = new Uint8Array(size);
		let bytesCopied = 0;
		while (bytesCopied < size) {
			const chunk = chunks[0];
			const bytesToCopy = Math.min(size - bytesCopied, chunk.length - offset);
			data.set(chunk.subarray(offset, offset + bytesToCopy), bytesCopied);
			bytesCopied += bytesToCopy;
			offset += bytesToCopy;
			if (offset === chunk.length) {
				chunks.shift();
				offset = 0;
			}
		}
		return data;
	}
function forward(size, targetController) {
		const bytesToForward = Math.min(size, totalLength);
		let forwarded = 0;
		while (forwarded < bytesToForward && chunks.length > 0) {
			const firstChunk = chunks[0];
			const availableInChunk = firstChunk.length - offset;
			const bytesToSend = Math.min(bytesToForward - forwarded, availableInChunk);
			targetController.enqueue(firstChunk.subarray(offset, offset + bytesToSend));
			forwarded += bytesToSend;
			offset += bytesToSend;
			if (offset === firstChunk.length) {
				chunks.shift();
				offset = 0;
			}
		}
		totalLength -= forwarded;
		return forwarded;
	}
function unshift(data) {
		if (offset > 0) {
			chunks[0] = chunks[0].subarray(offset);
			offset = 0;
		}
		chunks.unshift(data);
		totalLength += data.length;
	}
	return new TransformStream({
		transform(chunk, controller) {
			chunks.push(chunk);
			totalLength += chunk.length;
			while (true) {
				if (currentEntry) {
					const forwarded = forward(currentEntry.bytesLeft, currentEntry.controller);
					currentEntry.bytesLeft -= forwarded;
					if (currentEntry.bytesLeft === 0) {
						const padding = -currentEntry.header.size & BLOCK_SIZE_MASK;
						if (consume(padding) === null) break;
						try {
							currentEntry.controller.close();
						} catch {}
						currentEntry = null;
					} else break;
				}
				const headerBlock = consume(BLOCK_SIZE);
				if (headerBlock === null) break;
				if (headerBlock.every((b) => b === 0)) {
					const nextBlock = consume(BLOCK_SIZE);
					if (nextBlock === null) {
						unshift(headerBlock);
						break;
					}
					if (nextBlock.every((b) => b === 0)) {
						controller.terminate();
						return;
					} else {
						unshift(nextBlock);
						unshift(headerBlock);
					}
				}
				const header = parseUstarHeader(headerBlock, strict);
				const metaParser = getMetaParser(header.type);
				if (metaParser) {
					const dataSize = header.size;
					const dataBlocksSize = dataSize + BLOCK_SIZE_MASK & -BLOCK_SIZE;
					if (totalLength < dataBlocksSize) {
						unshift(headerBlock);
						break;
					}
					const data = consume(dataSize);
					if (data === null) {
						unshift(headerBlock);
						break;
					}
					const padding = dataBlocksSize - dataSize;
					if (padding > 0) {
						if (consume(padding) === null) {
							unshift(data);
							unshift(headerBlock);
							break;
						}
					}
					const overrides = metaParser(data);
					if (header.type === "pax-global-header") paxGlobals = Object.assign({}, paxGlobals, overrides);
					else nextEntryOverrides = Object.assign({}, nextEntryOverrides, overrides);
					continue;
				}
				const finalHeader = header;
				applyOverrides(finalHeader, paxGlobals);
				applyOverrides(finalHeader, nextEntryOverrides);
				if (header.prefix && header.magic === "ustar" && !nextEntryOverrides.name && !paxGlobals.name) finalHeader.name = `${header.prefix}/${finalHeader.name}`;
				nextEntryOverrides = {};
				let bodyController;
				const body = new ReadableStream({ start: (c) => bodyController = c });
				controller.enqueue({
					header: finalHeader,
					body
				});
				if (finalHeader.size > 0) currentEntry = {
					header: finalHeader,
					bytesLeft: finalHeader.size,
					controller: bodyController
				};
				else try {
					bodyController.close();
				} catch {}
			}
		},
		flush(controller) {
			if (currentEntry) if (strict) {
				const error = /* @__PURE__ */ new Error(`Tar archive is truncated. Expected ${currentEntry.header.size} bytes but received ${currentEntry.header.size - currentEntry.bytesLeft}.`);
				currentEntry.controller.error(error);
				controller.error(error);
			} else try {
				currentEntry.controller.close();
			} catch {}
			if (strict) {
				if (chunks.length > 0 && offset < chunks[0].length) {
					if (chunks[0].subarray(offset).some((b) => b !== 0)) {
						controller.error(/* @__PURE__ */ new Error("Unexpected data at end of archive."));
						return;
					}
				}
				for (let i = 1; i < chunks.length; i++) if (chunks[i].some((b) => b !== 0)) {
					controller.error(/* @__PURE__ */ new Error("Unexpected data at end of archive."));
					return;
				}
			}
		}
	});
}
function parseUstarHeader(block, strict) {
	if (strict && !validateChecksum(block)) throw new Error("Invalid tar header checksum.");
	const typeflag = readString(block, USTAR_TYPEFLAG_OFFSET, USTAR_TYPEFLAG_SIZE);
	const magic = readString(block, USTAR_MAGIC_OFFSET, USTAR_MAGIC_SIZE);
	if (strict && magic !== "ustar") throw new Error(`Invalid USTAR magic: expected "ustar", got "${magic}"`);
	return {
		name: readString(block, USTAR_NAME_OFFSET, USTAR_NAME_SIZE),
		mode: readOctal(block, USTAR_MODE_OFFSET, USTAR_MODE_SIZE),
		uid: readNumeric(block, USTAR_UID_OFFSET, USTAR_UID_SIZE),
		gid: readNumeric(block, USTAR_GID_OFFSET, USTAR_GID_SIZE),
		size: readNumeric(block, USTAR_SIZE_OFFSET, USTAR_SIZE_SIZE),
		mtime: /* @__PURE__ */ new Date(readNumeric(block, USTAR_MTIME_OFFSET, USTAR_MTIME_SIZE) * 1e3),
		checksum: readOctal(block, USTAR_CHECKSUM_OFFSET, USTAR_CHECKSUM_SIZE),
		type: FLAGTYPE[typeflag] || "file",
		linkname: readString(block, USTAR_LINKNAME_OFFSET, USTAR_LINKNAME_SIZE),
		magic,
		uname: readString(block, USTAR_UNAME_OFFSET, USTAR_UNAME_SIZE),
		gname: readString(block, USTAR_GNAME_OFFSET, USTAR_GNAME_SIZE),
		prefix: readString(block, USTAR_PREFIX_OFFSET, USTAR_PREFIX_SIZE)
	};
}
function parsePax(buffer) {
	const overrides = {};
	const pax = {};
	let offset = 0;
	while (offset < buffer.length) {
		const spaceIndex = buffer.indexOf(32, offset);
		if (spaceIndex === -1) break;
		const length = parseInt(decoder.decode(buffer.subarray(offset, spaceIndex)), 10);
		if (Number.isNaN(length) || length === 0) break;
		const recordEnd = offset + length;
		const [key, value] = decoder.decode(buffer.subarray(spaceIndex + 1, recordEnd - 1)).split("=", 2);
		if (key && value !== void 0) {
			pax[key] = value;
			switch (key) {
				case "path":
					overrides.name = value;
					break;
				case "linkpath":
					overrides.linkname = value;
					break;
				case "size":
					overrides.size = parseInt(value, 10);
					break;
				case "mtime":
					overrides.mtime = parseFloat(value);
					break;
				case "uid":
					overrides.uid = parseInt(value, 10);
					break;
				case "gid":
					overrides.gid = parseInt(value, 10);
					break;
				case "uname":
					overrides.uname = value;
					break;
				case "gname":
					overrides.gname = value;
					break;
			}
		}
		offset = recordEnd;
	}
	if (Object.keys(pax).length > 0) overrides.pax = pax;
	return overrides;
}
function applyOverrides(header, overrides) {
	if (overrides.name !== void 0) header.name = overrides.name;
	if (overrides.linkname !== void 0) header.linkname = overrides.linkname;
	if (overrides.size !== void 0) header.size = overrides.size;
	if (overrides.mtime !== void 0) header.mtime = /* @__PURE__ */ new Date(overrides.mtime * 1e3);
	if (overrides.uid !== void 0) header.uid = overrides.uid;
	if (overrides.gid !== void 0) header.gid = overrides.gid;
	if (overrides.uname !== void 0) header.uname = overrides.uname;
	if (overrides.gname !== void 0) header.gname = overrides.gname;
	if (overrides.pax) header.pax = Object.assign({}, header.pax ?? {}, overrides.pax);
}
function getMetaParser(type) {
	switch (type) {
		case "pax-global-header":
		case "pax-header": return parsePax;
		case "gnu-long-name": return (data) => ({ name: readString(data, 0, data.length) });
		case "gnu-long-link-name": return (data) => ({ linkname: readString(data, 0, data.length) });
		default: return;
	}
}

//#endregion
//#region src/web/helpers.ts
async function packTar(entries) {
	const { readable, controller } = createTarPacker();
	await (async () => {
		for (const entry of entries) {
			const entryStream = controller.add(entry.header);
			const { body } = entry;
			if (!body) {
				await entryStream.close();
				continue;
			}
			if (body instanceof ReadableStream) await body.pipeTo(entryStream);
			else if (body instanceof Blob) await body.stream().pipeTo(entryStream);
			else {
				let chunk;
				if (body === null || body === void 0) chunk = new Uint8Array(0);
				else if (body instanceof Uint8Array) chunk = body;
				else if (body instanceof ArrayBuffer) chunk = new Uint8Array(body);
				else if (typeof body === "string") chunk = encoder.encode(body);
				else throw new TypeError(`Unsupported content type for entry "${entry.header.name}". Expected string, Uint8Array, ArrayBuffer, Blob, ReadableStream, or undefined.`);
				const writer = entryStream.getWriter();
				await writer.write(chunk);
				await writer.close();
			}
		}
	})().then(() => controller.finalize()).catch((err) => controller.error(err));
	return new Uint8Array(await streamToBuffer(readable));
}
async function unpackTar(archive, options = {}) {
	const sourceStream = archive instanceof ReadableStream ? archive : new ReadableStream({ start(controller) {
		controller.enqueue(archive instanceof Uint8Array ? archive : new Uint8Array(archive));
		controller.close();
	} });
	const results = [];
	const reader = sourceStream.pipeThrough(createTarDecoder(options)).pipeThrough(createTarOptionsTransformer(options)).getReader();
	try {
		while (true) {
			const { done, value: entry } = await reader.read();
			if (done) break;
			results.push({
				header: entry.header,
				data: await streamToBuffer(entry.body)
			});
		}
	} finally {
		reader.releaseLock();
	}
	return results;
}

//#endregion
export { BLOCK_SIZE, BLOCK_SIZE_MASK, createGzipDecoder, createGzipEncoder, createTarDecoder, createTarHeader, createTarOptionsTransformer, createTarPacker, encoder, generatePax, packTar, streamToBuffer, unpackTar };